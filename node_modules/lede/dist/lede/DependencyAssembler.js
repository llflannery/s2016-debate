"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator.throw(value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments)).next());
    });
};
const lodash_1 = require("lodash");
const fs_extra_1 = require("fs-extra");
const https_1 = require("https");
const path_1 = require("path");
const os_1 = require("os");
const errors_1 = require("../errors");
const aml = require('archieml');
class DependencyAssembler {
    constructor(workingDir) {
        this.workingDir = workingDir;
    }
    /**
     * This will fetch all project dependencies, merge all baseContexts and fetch, parse, and merge all googleapis
     * content.
     * @returns {Promise<ProjectReport>}
     */
    assemble() {
        return __awaiter(this, void 0, Promise, function* () {
            let deps = yield DependencyAssembler.buildDependencies(this.workingDir);
            let origDep = deps[deps.length - 1];
            let context = lodash_1.merge(yield DependencyAssembler.buildContext(deps), { content: yield DependencyAssembler.buildContent(deps) }, { $projectName: origDep.name });
            return {
                workingDirectory: this.workingDir,
                context: context,
                dependencies: deps,
                styles: origDep.styles,
                scripts: origDep.scripts,
                blocks: origDep.blocks
            };
        });
    }
    /**
     * This method takes a rootDepDir string and returns a promise containing an ordered array of dependencies. Deps[0]
     * is the most-basic dependency; Deps[Deps.length - 1] is the project in rootDepDir.
     * @param rootDepDir - directory for starting dependency
     * @returns {Promise<Dependency[]>} - ordered list of dependencies
     */
    static buildDependencies(rootDepDir) {
        return __awaiter(this, void 0, Promise, function* () {
            return yield DependencyAssembler.reportOnDep(rootDepDir).then(r => DependencyAssembler.followLeaves(r, [], []));
        });
    }
    /**
     * Generates a Node on the dependency tree.
     * @param dir
     * @param calledBy
     * @returns {Promise<NodeReport>}
     */
    static reportOnDep(dir) {
        return __awaiter(this, void 0, Promise, function* () {
            let settings = yield DependencyAssembler.gatherSettings(dir);
            let leaves = [];
            for (let proj of settings.dependsOn) {
                leaves.push(path_1.resolve(settings.inheritanceRoot, proj));
            }
            settings.workingDir = dir;
            return { node: dir, settings: settings, leaves: leaves };
        });
    }
    /**
     * This method creates an ordered array of dependencies by following the specified node all the way to it's root
     * @param nodeReport
     * @param settingsArr
     * @param visited
     * @throws CircularDepError - thrown when a $currNode has a dependency on a node that depends on $currNode
     * @returns {Array<Dependency>}
     */
    static followLeaves(nodeReport, settingsArr, visited) {
        return __awaiter(this, void 0, Promise, function* () {
            visited.push(nodeReport.node);
            for (let leaf of nodeReport.leaves) {
                let leafReport = yield DependencyAssembler.reportOnDep(leaf);
                if (!(settingsArr.map(x => x.name).indexOf(leafReport.settings.name) > -1)) {
                    if (visited.indexOf(leafReport.node) > -1) {
                        throw new errors_1.CircularDepError(leafReport.node);
                    }
                    settingsArr = yield DependencyAssembler.followLeaves(leafReport, settingsArr, visited);
                }
            }
            settingsArr.push(nodeReport.settings);
            return settingsArr;
        });
    }
    /**
     * Gathers projectSettings file from specified directory and initializes then merges with default
     * @param dir
     * @returns {Promise<Dependency>}
     */
    static gatherSettings(dir) {
        return new Promise((resolve, reject) => {
            let path = path_1.resolve(dir, 'projectSettings.js');
            fs_extra_1.stat(path, (err, stats) => {
                if ((err && err.code === 'ENOENT') || !stats.isFile()) {
                    return reject(new errors_1.NotAFile(path));
                }
                else if (err) {
                    return reject(err);
                }
                else {
                    // Here we are importing a user-written module so we want to catch any errors it may throw
                    try {
                        let SettingsConfig = require(path).default;
                        let settings = new SettingsConfig();
                        return resolve(DependencyAssembler.setDepDefaults(settings));
                    }
                    catch (e) {
                        return reject(e);
                    }
                }
            });
        });
    }
    static setDepDefaults(settings) {
        if (!settings.inheritanceRoot) {
            settings.inheritanceRoot = process.env.LEDE_HOME ? path_1.resolve(os_1.homedir(), process.env.LEDE_HOME) : path_1.resolve(os_1.homedir(), "LedeProjects");
        }
        if (!settings.blocks) {
            settings.blocks = ["ARTICLE"];
        }
        if (!settings.scripts) {
            settings.scripts = [];
        }
        if (!settings.styles) {
            settings.styles = [];
        }
        if (!settings.name) {
            settings.name = "defaultLedeProject";
        }
        if (!settings.assets) {
            settings.assets = [];
        }
        if (!settings.googleFileId) {
            settings.googleFileId = "";
        }
        if (!settings.dependsOn) {
            settings.dependsOn = [];
        }
        return settings;
    }
    /**
     * Takes and array of dependencies, gathers baseContext (if any), and then merges child contexts onto root context.
     * @param deps
     * @returns {Promise<any>}
     */
    static buildContext(deps) {
        return __awaiter(this, void 0, Promise, function* () {
            let contexts = [];
            for (let dep of deps) {
                try {
                    let context = yield DependencyAssembler.gatherContext(dep.workingDir);
                    contexts.push(context);
                }
                catch (e) {
                    if (e.code === 'NotAFile') {
                    }
                    else {
                        throw e;
                    }
                }
            }
            return lodash_1.merge(...contexts);
        });
    }
    /**
     * Looks for and resolves a baseContext.js file if it exists in the directory. If ENOENT, resolves with an empty
     * object.
     * @param searchDir
     * @returns {Promise<any>}
     */
    static gatherContext(searchDir) {
        return new Promise((resolve, reject) => {
            let pathToContext = path_1.resolve(searchDir, 'baseContext.js');
            fs_extra_1.stat(pathToContext, (err, stats) => {
                if (err && err.code === 'ENOENT') {
                    return resolve({});
                }
                else if (err) {
                    return reject(err);
                }
                else if (!err && stats.isFile()) {
                    // Here we are importing a user-written modules so we want to catch any errors it may throw
                    try {
                        let Context = require(pathToContext).default;
                        return resolve(new Context());
                    }
                    catch (e) {
                        return reject(e);
                    }
                }
                else if (!stats.isFile()) {
                    return reject(new errors_1.NotAFile(pathToContext));
                }
            });
        });
    }
    /**
     * Gathers and merges content objects from deps if any
     * @param deps
     * @returns {Promise<Any>}
     */
    static buildContent(deps) {
        return __awaiter(this, void 0, Promise, function* () {
            let contents = [];
            for (let dep of deps) {
                if (dep.googleFileId) {
                    if (!process.env.GAPI_KEY) {
                        throw new Error("Must have a googleapis key saved in the env variable GAPI_KEY to access documents stored on google drive.");
                    }
                    let content = yield DependencyAssembler.fetchContent({ fileId: dep.googleFileId, apiKey: process.env.GAPI_KEY, parseFn: null });
                    contents.push(content);
                }
            }
            return lodash_1.merge(...contents);
        });
    }
    /**
     * Takes a resolver and returns the content it points to after passing it through the parser function. Defaults to
     * aml parser if none is specified.
     * @param resolver - Dependency content resolver taken from projectSettings.js for a project
     * @returns {Promise<Any>}
     */
    static fetchContent(resolver) {
        return new Promise((resolve, reject) => {
            let options = {
                hostname: 'www.googleapis.com',
                path: `/drive/v2/files/${resolver.fileId}?key=${resolver.apiKey}`,
                method: 'GET'
            };
            https_1.request(options, res => {
                let buffs = [];
                res.on('data', d => buffs.push(d));
                res.on('error', e => reject(e));
                res.on('end', () => {
                    let buffer = Buffer.concat(buffs);
                    let parsableResult = JSON.parse(buffer.toString('utf8'));
                    let plainUrl = parsableResult.exportLinks['text/plain'].slice(8);
                    options.hostname = plainUrl.split('/')[0];
                    options.path = `/${plainUrl.split('/').slice(1).join('/')}`;
                    https_1.request(options, res => {
                        let bufferArray = [];
                        res.on('data', d => bufferArray.push(d));
                        res.on('error', e => reject(e));
                        res.on('end', () => {
                            let buff = Buffer.concat(bufferArray);
                            if (!resolver.parseFn) {
                                resolve(aml.load(buff.toString('utf8')));
                            }
                            else {
                                resolve(resolver.parseFn(buff.toString('utf8')));
                            }
                        });
                    }).end();
                });
            }).end();
        });
    }
}
exports.DependencyAssembler = DependencyAssembler;

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImxlZGUvRGVwZW5kZW5jeUFzc2VtYmxlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQSx5QkFBc0IsUUFBUSxDQUFDLENBQUE7QUFDL0IsMkJBQTRCLFVBQVUsQ0FBQyxDQUFBO0FBQ3ZDLHdCQUF3QixPQUFPLENBQUMsQ0FBQTtBQUNoQyx1QkFBb0MsTUFBTSxDQUFDLENBQUE7QUFDM0MscUJBQXdCLElBQUksQ0FBQyxDQUFBO0FBRTdCLHlCQUEyQyxXQUFXLENBQUMsQ0FBQTtBQUN2RCxNQUFZLEdBQUcsV0FBTSxVQUFVLENBQUMsQ0FBQTtBQVVoQztJQUNFLFlBQW1CLFVBQWtCO1FBQWxCLGVBQVUsR0FBVixVQUFVLENBQVE7SUFDckMsQ0FBQztJQUVEOzs7O09BSUc7SUFDVSxRQUFROztZQUNuQixJQUFJLElBQUksR0FBRyxNQUFNLG1CQUFtQixDQUFDLGlCQUFpQixDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQztZQUN4RSxJQUFJLE9BQU8sR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUMsQ0FBQztZQUNwQyxJQUFJLE9BQU8sR0FBRyxjQUFLLENBQUMsTUFBTSxtQkFBbUIsQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUFDLEVBQzlELEVBQUMsT0FBTyxFQUFFLE1BQU0sbUJBQW1CLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxFQUFDLEVBQ3ZELEVBQUMsWUFBWSxFQUFFLE9BQU8sQ0FBQyxJQUFJLEVBQUMsQ0FBQyxDQUFDO1lBR2hDLE1BQU0sQ0FBQztnQkFDTCxnQkFBZ0IsRUFBRSxJQUFJLENBQUMsVUFBVTtnQkFDakMsU0FBQSxPQUFPO2dCQUNQLFlBQVksRUFBRSxJQUFJO2dCQUNsQixNQUFNLEVBQUUsT0FBTyxDQUFDLE1BQU07Z0JBQ3RCLE9BQU8sRUFBRSxPQUFPLENBQUMsT0FBTztnQkFDeEIsTUFBTSxFQUFFLE9BQU8sQ0FBQyxNQUFNO2FBQ3ZCLENBQUE7UUFDSCxDQUFD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QUFDO3dCQUNyQixHQUFHLENBQUMsRUFBRSxDQUFDLE1BQU0sRUFBRSxDQUFDLElBQUksV0FBVyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO3dCQUN6QyxHQUFHLENBQUMsRUFBRSxDQUFDLE9BQU8sRUFBRSxDQUFDLElBQUksTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7d0JBQ2hDLEdBQUcsQ0FBQyxFQUFFLENBQUMsS0FBSyxFQUFFOzRCQUNaLElBQUksSUFBSSxHQUFHLE1BQU0sQ0FBQyxNQUFNLENBQUMsV0FBVyxDQUFDLENBQUM7NEJBQ3RDLEVBQUUsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUM7Z0NBQ3RCLE9BQU8sQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDOzRCQUMzQyxDQUFDOzRCQUFDLElBQUksQ0FBQyxDQUFDO2dDQUNOLE9BQU8sQ0FBQyxRQUFRLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDOzRCQUNuRCxDQUFDO3dCQUNILENBQUMsQ0FBQyxDQUFBO29CQUNKLENBQUMsQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFBO2dCQUNWLENBQUMsQ0FBQyxDQUFBO1lBQ0osQ0FBQyxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUE7UUFDVixDQUFDLENBQUMsQ0FBQztJQUNMLENBQUM7QUFDSCxDQUFDO0FBdlBZLDJCQUFtQixzQkF1UC9CLENBQUEiLCJmaWxlIjoibGVkZS9EZXBlbmRlbmN5QXNzZW1ibGVyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgbWVyZ2UgfSBmcm9tIFwibG9kYXNoXCI7XG5pbXBvcnQgeyBzdGF0LCBTdGF0cyB9IGZyb20gXCJmcy1leHRyYVwiO1xuaW1wb3J0IHsgcmVxdWVzdCB9IGZyb20gXCJodHRwc1wiO1xuaW1wb3J0IHsgcmVzb2x2ZSBhcyBwcmVzb2x2ZSB9IGZyb20gXCJwYXRoXCI7XG5pbXBvcnQgeyBob21lZGlyIH0gZnJvbSBcIm9zXCI7XG5pbXBvcnQgeyBEZXBlbmRlbmN5LCBQcm9qZWN0UmVwb3J0LCBDb250ZW50UmVzb2x2ZXIgfSBmcm9tIFwiLi4vaW50ZXJmYWNlc1wiO1xuaW1wb3J0IHsgQ2lyY3VsYXJEZXBFcnJvciwgTm90QUZpbGUgfSBmcm9tIFwiLi4vZXJyb3JzXCI7XG5pbXBvcnQgKiBhcyBhbWwgZnJvbSAnYXJjaGllbWwnO1xuXG5cbmludGVyZmFjZSBOb2RlUmVwb3J0IHtcbiAgbm9kZTogc3RyaW5nO1xuICBzZXR0aW5nczogRGVwZW5kZW5jeTtcbiAgbGVhdmVzOiBzdHJpbmdbXTtcbn1cblxuXG5leHBvcnQgY2xhc3MgRGVwZW5kZW5jeUFzc2VtYmxlciB7XG4gIGNvbnN0cnVjdG9yKHB1YmxpYyB3b3JraW5nRGlyOiBzdHJpbmcpIHtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGlzIHdpbGwgZmV0Y2ggYWxsIHByb2plY3QgZGVwZW5kZW5jaWVzLCBtZXJnZSBhbGwgYmFzZUNvbnRleHRzIGFuZCBmZXRjaCwgcGFyc2UsIGFuZCBtZXJnZSBhbGwgZ29vZ2xlYXBpc1xuICAgKiBjb250ZW50LlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxQcm9qZWN0UmVwb3J0Pn1cbiAgICovXG4gIHB1YmxpYyBhc3luYyBhc3NlbWJsZSgpOiBQcm9taXNlPFByb2plY3RSZXBvcnQ+IHtcbiAgICBsZXQgZGVwcyA9IGF3YWl0IERlcGVuZGVuY3lBc3NlbWJsZXIuYnVpbGREZXBlbmRlbmNpZXModGhpcy53b3JraW5nRGlyKTtcbiAgICBsZXQgb3JpZ0RlcCA9IGRlcHNbZGVwcy5sZW5ndGggLSAxXTtcbiAgICBsZXQgY29udGV4dCA9IG1lcmdlKGF3YWl0IERlcGVuZGVuY3lBc3NlbWJsZXIuYnVpbGRDb250ZXh0KGRlcHMpLFxuICAgICAge2NvbnRlbnQ6IGF3YWl0IERlcGVuZGVuY3lBc3NlbWJsZXIuYnVpbGRDb250ZW50KGRlcHMpfSxcbiAgICAgIHskcHJvamVjdE5hbWU6IG9yaWdEZXAubmFtZX0pO1xuXG5cbiAgICByZXR1cm4ge1xuICAgICAgd29ya2luZ0RpcmVjdG9yeTogdGhpcy53b3JraW5nRGlyLFxuICAgICAgY29udGV4dCxcbiAgICAgIGRlcGVuZGVuY2llczogZGVwcyxcbiAgICAgIHN0eWxlczogb3JpZ0RlcC5zdHlsZXMsXG4gICAgICBzY3JpcHRzOiBvcmlnRGVwLnNjcmlwdHMsXG4gICAgICBibG9ja3M6IG9yaWdEZXAuYmxvY2tzXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFRoaXMgbWV0aG9kIHRha2VzIGEgcm9vdERlcERpciBzdHJpbmcgYW5kIHJldHVybnMgYSBwcm9taXNlIGNvbnRhaW5pbmcgYW4gb3JkZXJlZCBhcnJheSBvZiBkZXBlbmRlbmNpZXMuIERlcHNbMF1cbiAgICogaXMgdGhlIG1vc3QtYmFzaWMgZGVwZW5kZW5jeTsgRGVwc1tEZXBzLmxlbmd0aCAtIDFdIGlzIHRoZSBwcm9qZWN0IGluIHJvb3REZXBEaXIuXG4gICAqIEBwYXJhbSByb290RGVwRGlyIC0gZGlyZWN0b3J5IGZvciBzdGFydGluZyBkZXBlbmRlbmN5XG4gICAqIEByZXR1cm5zIHtQcm9taXNlPERlcGVuZGVuY3lbXT59IC0gb3JkZXJlZCBsaXN0IG9mIGRlcGVuZGVuY2llc1xuICAgKi9cbiAgcHVibGljIHN0YXRpYyBhc3luYyBidWlsZERlcGVuZGVuY2llcyhyb290RGVwRGlyOiBzdHJpbmcpOiBQcm9taXNlPERlcGVuZGVuY3lbXT4ge1xuICAgIHJldHVybiBhd2FpdCBEZXBlbmRlbmN5QXNzZW1ibGVyLnJlcG9ydE9uRGVwKHJvb3REZXBEaXIpLnRoZW4ociA9PiBEZXBlbmRlbmN5QXNzZW1ibGVyLmZvbGxvd0xlYXZlcyhyLCBbXSwgW10pKVxuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyBhIE5vZGUgb24gdGhlIGRlcGVuZGVuY3kgdHJlZS5cbiAgICogQHBhcmFtIGRpclxuICAgKiBAcGFyYW0gY2FsbGVkQnlcbiAgICogQHJldHVybnMge1Byb21pc2U8Tm9kZVJlcG9ydD59XG4gICAqL1xuICBwcml2YXRlIHN0YXRpYyBhc3luYyByZXBvcnRPbkRlcChkaXI6IHN0cmluZyk6IFByb21pc2U8Tm9kZVJlcG9ydD4ge1xuICAgIGxldCBzZXR0aW5ncyA9IGF3YWl0IERlcGVuZGVuY3lBc3NlbWJsZXIuZ2F0aGVyU2V0dGluZ3MoZGlyKTtcbiAgICBsZXQgbGVhdmVzID0gW107XG4gICAgZm9yIChsZXQgcHJvaiBvZiBzZXR0aW5ncy5kZXBlbmRzT24pIHtcbiAgICAgIGxlYXZlcy5wdXNoKHByZXNvbHZlKHNldHRpbmdzLmluaGVyaXRhbmNlUm9vdCwgcHJvaikpXG4gICAgfVxuICAgIHNldHRpbmdzLndvcmtpbmdEaXIgPSBkaXI7XG4gICAgcmV0dXJuIHtub2RlOiBkaXIsIHNldHRpbmdzLCBsZWF2ZXN9XG4gIH1cblxuICAvKipcbiAgICogVGhpcyBtZXRob2QgY3JlYXRlcyBhbiBvcmRlcmVkIGFycmF5IG9mIGRlcGVuZGVuY2llcyBieSBmb2xsb3dpbmcgdGhlIHNwZWNpZmllZCBub2RlIGFsbCB0aGUgd2F5IHRvIGl0J3Mgcm9vdFxuICAgKiBAcGFyYW0gbm9kZVJlcG9ydFxuICAgKiBAcGFyYW0gc2V0dGluZ3NBcnJcbiAgICogQHBhcmFtIHZpc2l0ZWRcbiAgICogQHRocm93cyBDaXJjdWxhckRlcEVycm9yIC0gdGhyb3duIHdoZW4gYSAkY3Vyck5vZGUgaGFzIGEgZGVwZW5kZW5jeSBvbiBhIG5vZGUgdGhhdCBkZXBlbmRzIG9uICRjdXJyTm9kZVxuICAgKiBAcmV0dXJucyB7QXJyYXk8RGVwZW5kZW5jeT59XG4gICAqL1xuICBwcml2YXRlIHN0YXRpYyBhc3luYyBmb2xsb3dMZWF2ZXMobm9kZVJlcG9ydDogTm9kZVJlcG9ydCwgc2V0dGluZ3NBcnI6IEFycmF5PERlcGVuZGVuY3k+LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmlzaXRlZDogc3RyaW5nW10pOiBQcm9taXNlPERlcGVuZGVuY3lbXT4ge1xuICAgIHZpc2l0ZWQucHVzaChub2RlUmVwb3J0Lm5vZGUpO1xuICAgIGZvciAobGV0IGxlYWYgb2Ygbm9kZVJlcG9ydC5sZWF2ZXMpIHtcbiAgICAgIGxldCBsZWFmUmVwb3J0ID0gYXdhaXQgRGVwZW5kZW5jeUFzc2VtYmxlci5yZXBvcnRPbkRlcChsZWFmKTtcbiAgICAgIGlmICghKHNldHRpbmdzQXJyLm1hcCh4ID0+IHgubmFtZSkuaW5kZXhPZihsZWFmUmVwb3J0LnNldHRpbmdzLm5hbWUpID4gLTEpKSB7XG4gICAgICAgIGlmICh2aXNpdGVkLmluZGV4T2YobGVhZlJlcG9ydC5ub2RlKSA+IC0xKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IENpcmN1bGFyRGVwRXJyb3IobGVhZlJlcG9ydC5ub2RlKVxuICAgICAgICB9XG4gICAgICAgIHNldHRpbmdzQXJyID0gYXdhaXQgRGVwZW5kZW5jeUFzc2VtYmxlci5mb2xsb3dMZWF2ZXMobGVhZlJlcG9ydCwgc2V0dGluZ3NBcnIsIHZpc2l0ZWQpO1xuICAgICAgfVxuICAgIH1cbiAgICBzZXR0aW5nc0Fyci5wdXNoKG5vZGVSZXBvcnQuc2V0dGluZ3MpO1xuICAgIHJldHVybiBzZXR0aW5nc0FycjtcbiAgfVxuXG4gIC8qKlxuICAgKiBHYXRoZXJzIHByb2plY3RTZXR0aW5ncyBmaWxlIGZyb20gc3BlY2lmaWVkIGRpcmVjdG9yeSBhbmQgaW5pdGlhbGl6ZXMgdGhlbiBtZXJnZXMgd2l0aCBkZWZhdWx0XG4gICAqIEBwYXJhbSBkaXJcbiAgICogQHJldHVybnMge1Byb21pc2U8RGVwZW5kZW5jeT59XG4gICAqL1xuICBwdWJsaWMgc3RhdGljIGdhdGhlclNldHRpbmdzKGRpcik6IFByb21pc2U8RGVwZW5kZW5jeT4ge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBsZXQgcGF0aCA9IHByZXNvbHZlKGRpciwgJ3Byb2plY3RTZXR0aW5ncy5qcycpO1xuICAgICAgc3RhdChwYXRoLCAoZXJyOiBhbnksIHN0YXRzOiBTdGF0cykgPT4ge1xuICAgICAgICBpZiAoKGVyciAmJiBlcnIuY29kZSA9PT0gJ0VOT0VOVCcpIHx8ICFzdGF0cy5pc0ZpbGUoKSkge1xuICAgICAgICAgIHJldHVybiByZWplY3QobmV3IE5vdEFGaWxlKHBhdGgpKTtcbiAgICAgICAgfSBlbHNlIGlmIChlcnIpIHtcbiAgICAgICAgICByZXR1cm4gcmVqZWN0KGVycilcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBIZXJlIHdlIGFyZSBpbXBvcnRpbmcgYSB1c2VyLXdyaXR0ZW4gbW9kdWxlIHNvIHdlIHdhbnQgdG8gY2F0Y2ggYW55IGVycm9ycyBpdCBtYXkgdGhyb3dcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgbGV0IFNldHRpbmdzQ29uZmlnOiBPYmplY3RDb25zdHJ1Y3RvciA9IHJlcXVpcmUocGF0aCkuZGVmYXVsdDtcbiAgICAgICAgICAgIGxldCBzZXR0aW5nczogRGVwZW5kZW5jeSA9IDxhbnk+bmV3IFNldHRpbmdzQ29uZmlnKCk7XG5cbiAgICAgICAgICAgIHJldHVybiByZXNvbHZlKERlcGVuZGVuY3lBc3NlbWJsZXIuc2V0RGVwRGVmYXVsdHMoc2V0dGluZ3MpKTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVqZWN0KGUpXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH0pO1xuICB9XG5cbiAgcHVibGljIHN0YXRpYyBzZXREZXBEZWZhdWx0cyhzZXR0aW5nczogRGVwZW5kZW5jeSkge1xuICAgIGlmICghc2V0dGluZ3MuaW5oZXJpdGFuY2VSb290KSB7XG4gICAgICBzZXR0aW5ncy5pbmhlcml0YW5jZVJvb3QgPSBwcm9jZXNzLmVudi5MRURFX0hPTUUgPyBwcmVzb2x2ZShob21lZGlyKCksIHByb2Nlc3MuZW52LkxFREVfSE9NRSkgOiBwcmVzb2x2ZShcbiAgICAgICAgaG9tZWRpcigpLCBcIkxlZGVQcm9qZWN0c1wiKTtcbiAgICB9XG4gICAgaWYgKCFzZXR0aW5ncy5ibG9ja3MpIHtcbiAgICAgIHNldHRpbmdzLmJsb2NrcyA9IFtcIkFSVElDTEVcIl07XG4gICAgfVxuICAgIGlmICghc2V0dGluZ3Muc2NyaXB0cykge1xuICAgICAgc2V0dGluZ3Muc2NyaXB0cyA9IFtdO1xuICAgIH1cbiAgICBpZiAoIXNldHRpbmdzLnN0eWxlcykge1xuICAgICAgc2V0dGluZ3Muc3R5bGVzID0gW107XG4gICAgfVxuICAgIGlmICghc2V0dGluZ3MubmFtZSkge1xuICAgICAgc2V0dGluZ3MubmFtZSA9IFwiZGVmYXVsdExlZGVQcm9qZWN0XCI7XG4gICAgfVxuICAgIGlmICghc2V0dGluZ3MuYXNzZXRzKSB7XG4gICAgICBzZXR0aW5ncy5hc3NldHMgPSBbXTtcbiAgICB9XG4gICAgaWYgKCFzZXR0aW5ncy5nb29nbGVGaWxlSWQpIHtcbiAgICAgIHNldHRpbmdzLmdvb2dsZUZpbGVJZCA9IFwiXCI7XG4gICAgfVxuICAgIGlmICghc2V0dGluZ3MuZGVwZW5kc09uKSB7XG4gICAgICBzZXR0aW5ncy5kZXBlbmRzT24gPSBbXTtcbiAgICB9XG4gICAgcmV0dXJuIHNldHRpbmdzO1xuICB9XG5cbiAgLyoqXG4gICAqIFRha2VzIGFuZCBhcnJheSBvZiBkZXBlbmRlbmNpZXMsIGdhdGhlcnMgYmFzZUNvbnRleHQgKGlmIGFueSksIGFuZCB0aGVuIG1lcmdlcyBjaGlsZCBjb250ZXh0cyBvbnRvIHJvb3QgY29udGV4dC5cbiAgICogQHBhcmFtIGRlcHNcbiAgICogQHJldHVybnMge1Byb21pc2U8YW55Pn1cbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgYXN5bmMgYnVpbGRDb250ZXh0KGRlcHM6IEFycmF5PERlcGVuZGVuY3k+KTogUHJvbWlzZTxhbnk+IHtcbiAgICBsZXQgY29udGV4dHMgPSBbXTtcbiAgICBmb3IgKGxldCBkZXAgb2YgZGVwcykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgbGV0IGNvbnRleHQgPSBhd2FpdCBEZXBlbmRlbmN5QXNzZW1ibGVyLmdhdGhlckNvbnRleHQoZGVwLndvcmtpbmdEaXIpO1xuICAgICAgICBjb250ZXh0cy5wdXNoKGNvbnRleHQpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBpZiAoZS5jb2RlID09PSAnTm90QUZpbGUnKSB7XG4gICAgICAgICAgLy8gSGVyZSB3b3VsZCBiZSBhIGdvb2QgdGltZSB0byB1c2UgYW4gZXZlbnQgZW1pdHRlciBvciBsb2dnZXJcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICB9XG4gICAgcmV0dXJuIG1lcmdlKC4uLmNvbnRleHRzKVxuICB9XG5cbiAgLyoqXG4gICAqIExvb2tzIGZvciBhbmQgcmVzb2x2ZXMgYSBiYXNlQ29udGV4dC5qcyBmaWxlIGlmIGl0IGV4aXN0cyBpbiB0aGUgZGlyZWN0b3J5LiBJZiBFTk9FTlQsIHJlc29sdmVzIHdpdGggYW4gZW1wdHlcbiAgICogb2JqZWN0LlxuICAgKiBAcGFyYW0gc2VhcmNoRGlyXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPGFueT59XG4gICAqL1xuICBwdWJsaWMgc3RhdGljIGdhdGhlckNvbnRleHQoc2VhcmNoRGlyOiBzdHJpbmcpOiBQcm9taXNlPGFueT4ge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBsZXQgcGF0aFRvQ29udGV4dCA9IHByZXNvbHZlKHNlYXJjaERpciwgJ2Jhc2VDb250ZXh0LmpzJyk7XG4gICAgICBzdGF0KHBhdGhUb0NvbnRleHQsIChlcnI6IGFueSwgc3RhdHM6IFN0YXRzKSA9PiB7XG4gICAgICAgIGlmIChlcnIgJiYgZXJyLmNvZGUgPT09ICdFTk9FTlQnKSB7XG4gICAgICAgICAgcmV0dXJuIHJlc29sdmUoe30pO1xuICAgICAgICB9IGVsc2UgaWYgKGVycikge1xuICAgICAgICAgIHJldHVybiByZWplY3QoZXJyKTtcbiAgICAgICAgfSBlbHNlIGlmICghZXJyICYmIHN0YXRzLmlzRmlsZSgpKSB7XG4gICAgICAgICAgLy8gSGVyZSB3ZSBhcmUgaW1wb3J0aW5nIGEgdXNlci13cml0dGVuIG1vZHVsZXMgc28gd2Ugd2FudCB0byBjYXRjaCBhbnkgZXJyb3JzIGl0IG1heSB0aHJvd1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBsZXQgQ29udGV4dDogT2JqZWN0Q29uc3RydWN0b3IgPSByZXF1aXJlKHBhdGhUb0NvbnRleHQpLmRlZmF1bHQ7XG4gICAgICAgICAgICByZXR1cm4gcmVzb2x2ZShuZXcgQ29udGV4dCgpKVxuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHJldHVybiByZWplY3QoZSlcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoIXN0YXRzLmlzRmlsZSgpKSB7XG4gICAgICAgICAgcmV0dXJuIHJlamVjdChuZXcgTm90QUZpbGUocGF0aFRvQ29udGV4dCkpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogR2F0aGVycyBhbmQgbWVyZ2VzIGNvbnRlbnQgb2JqZWN0cyBmcm9tIGRlcHMgaWYgYW55XG4gICAqIEBwYXJhbSBkZXBzXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPEFueT59XG4gICAqL1xuICBwdWJsaWMgc3RhdGljIGFzeW5jIGJ1aWxkQ29udGVudChkZXBzOiBEZXBlbmRlbmN5W10pOiBQcm9taXNlPGFueT4ge1xuICAgIGxldCBjb250ZW50cyA9IFtdO1xuICAgIGZvciAobGV0IGRlcCBvZiBkZXBzKSB7XG4gICAgICBpZiAoZGVwLmdvb2dsZUZpbGVJZCkge1xuICAgICAgICBpZiAoIXByb2Nlc3MuZW52LkdBUElfS0VZKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTXVzdCBoYXZlIGEgZ29vZ2xlYXBpcyBrZXkgc2F2ZWQgaW4gdGhlIGVudiB2YXJpYWJsZSBHQVBJX0tFWSB0byBhY2Nlc3MgZG9jdW1lbnRzIHN0b3JlZCBvbiBnb29nbGUgZHJpdmUuXCIpXG4gICAgICAgIH1cbiAgICAgICAgbGV0IGNvbnRlbnQgPSBhd2FpdCBEZXBlbmRlbmN5QXNzZW1ibGVyLmZldGNoQ29udGVudChcbiAgICAgICAgICB7ZmlsZUlkOiBkZXAuZ29vZ2xlRmlsZUlkLCBhcGlLZXk6IHByb2Nlc3MuZW52LkdBUElfS0VZLCBwYXJzZUZuOiBudWxsfSk7XG4gICAgICAgIGNvbnRlbnRzLnB1c2goY29udGVudClcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1lcmdlKC4uLmNvbnRlbnRzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUYWtlcyBhIHJlc29sdmVyIGFuZCByZXR1cm5zIHRoZSBjb250ZW50IGl0IHBvaW50cyB0byBhZnRlciBwYXNzaW5nIGl0IHRocm91Z2ggdGhlIHBhcnNlciBmdW5jdGlvbi4gRGVmYXVsdHMgdG9cbiAgICogYW1sIHBhcnNlciBpZiBub25lIGlzIHNwZWNpZmllZC5cbiAgICogQHBhcmFtIHJlc29sdmVyIC0gRGVwZW5kZW5jeSBjb250ZW50IHJlc29sdmVyIHRha2VuIGZyb20gcHJvamVjdFNldHRpbmdzLmpzIGZvciBhIHByb2plY3RcbiAgICogQHJldHVybnMge1Byb21pc2U8QW55Pn1cbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgZmV0Y2hDb250ZW50KHJlc29sdmVyOiBDb250ZW50UmVzb2x2ZXIpOiBQcm9taXNlPGFueT4ge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBsZXQgb3B0aW9ucyA9IHtcbiAgICAgICAgaG9zdG5hbWU6ICd3d3cuZ29vZ2xlYXBpcy5jb20nLFxuICAgICAgICBwYXRoOiBgL2RyaXZlL3YyL2ZpbGVzLyR7cmVzb2x2ZXIuZmlsZUlkfT9rZXk9JHtyZXNvbHZlci5hcGlLZXl9YCxcbiAgICAgICAgbWV0aG9kOiAnR0VUJ1xuICAgICAgfTtcblxuICAgICAgcmVxdWVzdChvcHRpb25zLCByZXMgPT4ge1xuICAgICAgICBsZXQgYnVmZnMgPSBbXTtcbiAgICAgICAgcmVzLm9uKCdkYXRhJywgZCA9PiBidWZmcy5wdXNoKGQpKTtcbiAgICAgICAgcmVzLm9uKCdlcnJvcicsIGUgPT4gcmVqZWN0KGUpKTtcbiAgICAgICAgcmVzLm9uKCdlbmQnLCAoKSA9PiB7XG4gICAgICAgICAgbGV0IGJ1ZmZlciA9IEJ1ZmZlci5jb25jYXQoYnVmZnMpO1xuICAgICAgICAgIGxldCBwYXJzYWJsZVJlc3VsdDoge2V4cG9ydExpbmtzOiBzdHJpbmd9ID0gSlNPTi5wYXJzZShidWZmZXIudG9TdHJpbmcoJ3V0ZjgnKSk7XG4gICAgICAgICAgbGV0IHBsYWluVXJsOiBzdHJpbmcgPSBwYXJzYWJsZVJlc3VsdC5leHBvcnRMaW5rc1sndGV4dC9wbGFpbiddLnNsaWNlKDgpO1xuICAgICAgICAgIG9wdGlvbnMuaG9zdG5hbWUgPSBwbGFpblVybC5zcGxpdCgnLycpWzBdO1xuICAgICAgICAgIG9wdGlvbnMucGF0aCA9IGAvJHtwbGFpblVybC5zcGxpdCgnLycpLnNsaWNlKDEpLmpvaW4oJy8nKX1gO1xuICAgICAgICAgIHJlcXVlc3Qob3B0aW9ucywgcmVzID0+IHtcbiAgICAgICAgICAgIGxldCBidWZmZXJBcnJheSA9IFtdO1xuICAgICAgICAgICAgcmVzLm9uKCdkYXRhJywgZCA9PiBidWZmZXJBcnJheS5wdXNoKGQpKTtcbiAgICAgICAgICAgIHJlcy5vbignZXJyb3InLCBlID0+IHJlamVjdChlKSk7XG4gICAgICAgICAgICByZXMub24oJ2VuZCcsICgpID0+IHtcbiAgICAgICAgICAgICAgbGV0IGJ1ZmYgPSBCdWZmZXIuY29uY2F0KGJ1ZmZlckFycmF5KTtcbiAgICAgICAgICAgICAgaWYgKCFyZXNvbHZlci5wYXJzZUZuKSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShhbWwubG9hZChidWZmLnRvU3RyaW5nKCd1dGY4JykpKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlKHJlc29sdmVyLnBhcnNlRm4oYnVmZi50b1N0cmluZygndXRmOCcpKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfSkuZW5kKClcbiAgICAgICAgfSlcbiAgICAgIH0pLmVuZCgpXG4gICAgfSk7XG4gIH1cbn0iXSwic291cmNlUm9vdCI6Ii9Vc2Vycy9lbXVycmF5L1dlYnN0b3JtUHJvamVjdHMvbGVkZS9zcmMifQ==
