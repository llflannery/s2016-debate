"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator.throw(value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments)).next());
    });
};
const browserify = require("browserify");
const babelify = require("babelify");
const path_1 = require("path");
const glob = require("glob");
function globProm(path, cwd) {
    return new Promise((resolve, reject) => {
        glob(path, {
            cwd: cwd ? cwd : process.cwd()
        }, (err, paths) => {
            if (err) {
                return reject(err);
            }
            return resolve(paths);
        });
    });
}
class Es6Compiler {
    constructor(options) {
        this.options = options;
    }
    ;
    compile(report, usedBits) {
        return __awaiter(this, void 0, void 0, function* () {
            let requireable = yield Es6Compiler.getRequirablePaths(path_1.resolve(report.workingDirectory, ".ledeCache", "scripts"));
            let globals = yield Es6Compiler.bundleGlobals(report, requireable);
            let bits = yield Es6Compiler.bundleBits(report, requireable, usedBits);
            return {
                bits: bits,
                globals: globals
            };
        });
    }
    static bundleBits(report, requireable, bits) {
        return __awaiter(this, void 0, void 0, function* () {
            let bitPaths = bits.map(b => path_1.resolve(report.workingDirectory, ".ledeCache", "bits", b, "interact.js"));
            return Es6Compiler.bundleProm(bitPaths, requireable, path_1.resolve(report.workingDirectory, ".ledeCache", "scripts"), report.context.$debug);
        });
    }
    static bundleGlobals(report, requireable) {
        return __awaiter(this, void 0, void 0, function* () {
            let globalPaths = report.scripts.map(s => path_1.resolve(report.workingDirectory, ".ledeCache", "scripts", s));
            return yield Es6Compiler.bundleProm(globalPaths, requireable, path_1.resolve(report.workingDirectory, ".ledeCache", "scripts"), report.context.$debug);
        });
    }
    static bundleProm(toAdd, requireable, cwd, debug) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => {
                let b = browserify({ basedir: cwd, debug: debug });
                b.require(requireable);
                b.add(toAdd);
                b.transform(babelify, { presets: require('babel-preset-es2015') });
                b.bundle((err, res) => {
                    if (err)
                        return reject(err);
                    return resolve(res.toString());
                });
            });
        });
    }
    static getRequirablePaths(searchDir) {
        return __awaiter(this, void 0, void 0, function* () {
            let paths = [];
            let projects = yield globProm(`*`, searchDir);
            for (let proj of projects) {
                let projName = path_1.basename(proj);
                let files = yield globProm(`*`, path_1.resolve(searchDir, proj));
                for (let file of files) {
                    let fileName = path_1.basename(file);
                    paths.push({
                        file: path_1.resolve(searchDir, projName, fileName),
                        expose: `${projName}/${fileName}`
                    });
                }
            }
            return paths;
        });
    }
}
exports.Es6Compiler = Es6Compiler;

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImNvbXBpbGVycy9FczZDb21waWxlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQSxNQUFZLFVBQVUsV0FBTSxZQUFZLENBQUMsQ0FBQTtBQUN6QyxNQUFZLFFBQVEsV0FBTSxVQUFVLENBQUMsQ0FBQTtBQUNyQyx1QkFBa0MsTUFBTSxDQUFDLENBQUE7QUFDekMsTUFBWSxJQUFJLFdBQU0sTUFBTSxDQUFDLENBQUE7QUFJN0Isa0JBQWtCLElBQUksRUFBRSxHQUFJO0lBQzFCLE1BQU0sQ0FBQyxJQUFJLE9BQU8sQ0FBQyxDQUFDLE9BQU8sRUFBRSxNQUFNO1FBQ2pDLElBQUksQ0FBQyxJQUFJLEVBQUU7WUFDVCxHQUFHLEVBQUUsR0FBRyxHQUFHLEdBQUcsR0FBRSxPQUFPLENBQUMsR0FBRyxFQUFFO1NBQzlCLEVBQUUsQ0FBQyxHQUFHLEVBQUUsS0FBSztZQUNaLEVBQUUsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7Z0JBQ1IsTUFBTSxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQztZQUNyQixDQUFDO1lBQ0QsTUFBTSxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUN4QixDQUFDLENBQUMsQ0FBQTtJQUNKLENBQUMsQ0FBQyxDQUFDO0FBQ0wsQ0FBQztBQUdEO0lBQ0UsWUFBbUIsT0FBTztRQUFQLFlBQU8sR0FBUCxPQUFPLENBQUE7SUFBRyxDQUFDOztJQUV4QixPQUFPLENBQUMsTUFBcUIsRUFBRSxRQUFROztZQUMzQyxJQUFJLFdBQVcsR0FBRyxNQUFNLFdBQVcsQ0FBQyxrQkFBa0IsQ0FBQyxjQUFPLENBQUMsTUFBTSxDQUFDLGdCQUFnQixFQUFFLFlBQVksRUFBRSxTQUFTLENBQUMsQ0FBQyxDQUFDO1lBQ2xILElBQUksT0FBTyxHQUFHLE1BQU0sV0FBVyxDQUFDLGFBQWEsQ0FBQyxNQUFNLEVBQUUsV0FBVyxDQUFDLENBQUM7WUFDbkUsSUFBSSxJQUFJLEdBQUcsTUFBTSxXQUFXLENBQUMsVUFBVSxDQUFDLE1BQU0sRUFBRSxXQUFXLEVBQUUsUUFBUSxDQUFDLENBQUM7WUFDdkUsTUFBTSxDQUFDO2dCQUNMLE1BQUEsSUFBSTtnQkFDSixTQUFBLE9BQU87YUFDUixDQUFBO1FBQ0gsQ0FBQztLQUFBO0lBRUQsT0FBYSxVQUFVLENBQUMsTUFBcUIsRUFBRSxXQUFXLEVBQUUsSUFBSTs7WUFDOUQsSUFBSSxRQUFRLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLElBQUksY0FBTyxDQUFDLE1BQU0sQ0FBQyxnQkFBZ0IsRUFBRSxZQUFZLEVBQUUsTUFBTSxFQUFFLENBQUMsRUFBRSxhQUFhLENBQUMsQ0FBQyxDQUFDO1lBQ3ZHLE1BQU0sQ0FBQyxXQUFXLENBQUMsVUFBVSxDQUFDLFFBQVEsRUFBRSxXQUFXLEVBQUUsY0FBTyxDQUFDLE1BQU0sQ0FBQyxnQkFBZ0IsRUFBRSxZQUFZLEVBQUUsU0FBUyxDQUFDLEVBQUUsTUFBTSxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUMsQ0FBQztRQUN6SSxDQUFDO0tBQUE7SUFFRCxPQUFhLGFBQWEsQ0FBQyxNQUFxQixFQUFFLFdBQVc7O1lBQzNELElBQUksV0FBVyxHQUFHLE1BQU0sQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLENBQUMsSUFBSSxjQUFPLENBQUMsTUFBTSxDQUFDLGdCQUFnQixFQUFFLFlBQVksRUFBRSxTQUFTLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUN4RyxNQUFNLENBQUMsTUFBTSxXQUFXLENBQUMsVUFBVSxDQUFDLFdBQVcsRUFBRSxXQUFXLEVBQUUsY0FBTyxDQUFDLE1BQU0sQ0FBQyxnQkFBZ0IsRUFBRSxZQUFZLEVBQUUsU0FBUyxDQUFDLEVBQUUsTUFBTSxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUMsQ0FBQztRQUNsSixDQUFDO0tBQUE7SUFFRCxPQUFhLFVBQVUsQ0FBQyxLQUFLLEVBQUUsV0FBVyxFQUFFLEdBQUcsRUFBRSxLQUFLOztZQUNwRCxNQUFNLENBQUMsSUFBSSxPQUFPLENBQUMsQ0FBQyxPQUFPLEVBQUUsTUFBTTtnQkFDakMsSUFBSSxDQUFDLEdBQUcsVUFBVSxDQUFDLEVBQUMsT0FBTyxFQUFFLEdBQUcsRUFBRSxLQUFLLEVBQUUsS0FBSyxFQUFDLENBQUMsQ0FBQztnQkFDakQsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxXQUFXLENBQUMsQ0FBQztnQkFDdkIsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsQ0FBQztnQkFDYixDQUFDLENBQUMsU0FBUyxDQUFDLFFBQVEsRUFBRSxFQUFDLE9BQU8sRUFBRSxPQUFPLENBQUMscUJBQXFCLENBQUMsRUFBQyxDQUFDLENBQUM7Z0JBQ2pFLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxHQUFHLEVBQUUsR0FBRztvQkFDaEIsRUFBRSxDQUFDLENBQUMsR0FBRyxDQUFDO3dCQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUM7b0JBQzVCLE1BQU0sQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLFFBQVEsRUFBRSxDQUFDLENBQUE7Z0JBQ2hDLENBQUMsQ0FBQyxDQUFBO1lBQ0osQ0FBQyxDQUFDLENBQUM7UUFDTCxDQUFDO0tBQUE7SUFFRCxPQUFhLGtCQUFrQixDQUFDLFNBQVM7O1lBQ3ZDLElBQUksS0FBSyxHQUFHLEVBQUUsQ0FBQztZQUNmLElBQUksUUFBUSxHQUFHLE1BQU0sUUFBUSxDQUFDLEdBQUcsRUFBRSxTQUFTLENBQUMsQ0FBQztZQUM5QyxHQUFHLENBQUMsQ0FBQyxJQUFJLElBQUksSUFBSSxRQUFRLENBQUMsQ0FBQyxDQUFDO2dCQUMxQixJQUFJLFFBQVEsR0FBRyxlQUFRLENBQUMsSUFBSSxDQUFDLENBQUM7Z0JBQzlCLElBQUksS0FBSyxHQUFHLE1BQU0sUUFBUSxDQUFDLEdBQUcsRUFBRSxjQUFPLENBQUMsU0FBUyxFQUFFLElBQUksQ0FBQyxDQUFDLENBQUM7Z0JBQzFELEdBQUcsQ0FBQyxDQUFDLElBQUksSUFBSSxJQUFJLEtBQUssQ0FBQyxDQUFDLENBQUM7b0JBQ3ZCLElBQUksUUFBUSxHQUFHLGVBQVEsQ0FBQyxJQUFJLENBQUMsQ0FBQztvQkFDOUIsS0FBSyxDQUFDLElBQUksQ0FBQzt3QkFDVCxJQUFJLEVBQUUsY0FBTyxDQUFDLFNBQVMsRUFBRSxRQUFRLEVBQUUsUUFBUSxDQUFDO3dCQUM1QyxNQUFNLEVBQUUsR0FBRyxRQUFRLElBQUksUUFBUSxFQUFFO3FCQUNsQyxDQUFDLENBQUM7Z0JBQ0wsQ0FBQztZQUNILENBQUM7WUFDRCxNQUFNLENBQUMsS0FBSyxDQUFDO1FBQ2YsQ0FBQztLQUFBO0FBQ0gsQ0FBQztBQXBEWSxtQkFBVyxjQW9EdkIsQ0FBQSIsImZpbGUiOiJjb21waWxlcnMvRXM2Q29tcGlsZXIuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBicm93c2VyaWZ5IGZyb20gXCJicm93c2VyaWZ5XCI7XG5pbXBvcnQgKiBhcyBiYWJlbGlmeSBmcm9tIFwiYmFiZWxpZnlcIjtcbmltcG9ydCB7IGJhc2VuYW1lLCByZXNvbHZlIH0gZnJvbSBcInBhdGhcIjtcbmltcG9ydCAqIGFzIGdsb2IgZnJvbSBcImdsb2JcIjtcbmltcG9ydCB7IFByb2plY3RSZXBvcnQgfSBmcm9tIFwiLi4vaW50ZXJmYWNlcy9Qcm9qZWN0UmVwb3J0XCI7XG5cblxuZnVuY3Rpb24gZ2xvYlByb20ocGF0aCwgY3dkPyk6IFByb21pc2U8QXJyYXk8c3RyaW5nPj4ge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGdsb2IocGF0aCwge1xuICAgICAgY3dkOiBjd2QgPyBjd2Q6IHByb2Nlc3MuY3dkKClcbiAgICB9LCAoZXJyLCBwYXRocykgPT4ge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICByZXR1cm4gcmVqZWN0KGVycik7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzb2x2ZShwYXRocyk7XG4gICAgfSlcbiAgfSk7XG59XG5cblxuZXhwb3J0IGNsYXNzIEVzNkNvbXBpbGVyIHtcbiAgY29uc3RydWN0b3IocHVibGljIG9wdGlvbnMpIHt9O1xuXG4gIGFzeW5jIGNvbXBpbGUocmVwb3J0OiBQcm9qZWN0UmVwb3J0LCB1c2VkQml0cykge1xuICAgIGxldCByZXF1aXJlYWJsZSA9IGF3YWl0IEVzNkNvbXBpbGVyLmdldFJlcXVpcmFibGVQYXRocyhyZXNvbHZlKHJlcG9ydC53b3JraW5nRGlyZWN0b3J5LCBcIi5sZWRlQ2FjaGVcIiwgXCJzY3JpcHRzXCIpKTtcbiAgICBsZXQgZ2xvYmFscyA9IGF3YWl0IEVzNkNvbXBpbGVyLmJ1bmRsZUdsb2JhbHMocmVwb3J0LCByZXF1aXJlYWJsZSk7XG4gICAgbGV0IGJpdHMgPSBhd2FpdCBFczZDb21waWxlci5idW5kbGVCaXRzKHJlcG9ydCwgcmVxdWlyZWFibGUsIHVzZWRCaXRzKTtcbiAgICByZXR1cm4ge1xuICAgICAgYml0cyxcbiAgICAgIGdsb2JhbHNcbiAgICB9XG4gIH1cblxuICBzdGF0aWMgYXN5bmMgYnVuZGxlQml0cyhyZXBvcnQ6IFByb2plY3RSZXBvcnQsIHJlcXVpcmVhYmxlLCBiaXRzKSB7XG4gICAgbGV0IGJpdFBhdGhzID0gYml0cy5tYXAoYiA9PiByZXNvbHZlKHJlcG9ydC53b3JraW5nRGlyZWN0b3J5LCBcIi5sZWRlQ2FjaGVcIiwgXCJiaXRzXCIsIGIsIFwiaW50ZXJhY3QuanNcIikpO1xuICAgIHJldHVybiBFczZDb21waWxlci5idW5kbGVQcm9tKGJpdFBhdGhzLCByZXF1aXJlYWJsZSwgcmVzb2x2ZShyZXBvcnQud29ya2luZ0RpcmVjdG9yeSwgXCIubGVkZUNhY2hlXCIsIFwic2NyaXB0c1wiKSwgcmVwb3J0LmNvbnRleHQuJGRlYnVnKTtcbiAgfVxuICBcbiAgc3RhdGljIGFzeW5jIGJ1bmRsZUdsb2JhbHMocmVwb3J0OiBQcm9qZWN0UmVwb3J0LCByZXF1aXJlYWJsZSkge1xuICAgIGxldCBnbG9iYWxQYXRocyA9IHJlcG9ydC5zY3JpcHRzLm1hcChzID0+IHJlc29sdmUocmVwb3J0LndvcmtpbmdEaXJlY3RvcnksIFwiLmxlZGVDYWNoZVwiLCBcInNjcmlwdHNcIiwgcykpO1xuICAgIHJldHVybiBhd2FpdCBFczZDb21waWxlci5idW5kbGVQcm9tKGdsb2JhbFBhdGhzLCByZXF1aXJlYWJsZSwgcmVzb2x2ZShyZXBvcnQud29ya2luZ0RpcmVjdG9yeSwgXCIubGVkZUNhY2hlXCIsIFwic2NyaXB0c1wiKSwgcmVwb3J0LmNvbnRleHQuJGRlYnVnKTtcbiAgfVxuXG4gIHN0YXRpYyBhc3luYyBidW5kbGVQcm9tKHRvQWRkLCByZXF1aXJlYWJsZSwgY3dkLCBkZWJ1Zykge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBsZXQgYiA9IGJyb3dzZXJpZnkoe2Jhc2VkaXI6IGN3ZCwgZGVidWc6IGRlYnVnfSk7XG4gICAgICBiLnJlcXVpcmUocmVxdWlyZWFibGUpO1xuICAgICAgYi5hZGQodG9BZGQpO1xuICAgICAgYi50cmFuc2Zvcm0oYmFiZWxpZnksIHtwcmVzZXRzOiByZXF1aXJlKCdiYWJlbC1wcmVzZXQtZXMyMDE1Jyl9KTtcbiAgICAgIGIuYnVuZGxlKChlcnIsIHJlcykgPT4ge1xuICAgICAgICBpZiAoZXJyKSByZXR1cm4gcmVqZWN0KGVycik7XG4gICAgICAgIHJldHVybiByZXNvbHZlKHJlcy50b1N0cmluZygpKVxuICAgICAgfSlcbiAgICB9KTtcbiAgfVxuXG4gIHN0YXRpYyBhc3luYyBnZXRSZXF1aXJhYmxlUGF0aHMoc2VhcmNoRGlyKSB7XG4gICAgbGV0IHBhdGhzID0gW107XG4gICAgbGV0IHByb2plY3RzID0gYXdhaXQgZ2xvYlByb20oYCpgLCBzZWFyY2hEaXIpO1xuICAgIGZvciAobGV0IHByb2ogb2YgcHJvamVjdHMpIHtcbiAgICAgIGxldCBwcm9qTmFtZSA9IGJhc2VuYW1lKHByb2opO1xuICAgICAgbGV0IGZpbGVzID0gYXdhaXQgZ2xvYlByb20oYCpgLCByZXNvbHZlKHNlYXJjaERpciwgcHJvaikpO1xuICAgICAgZm9yIChsZXQgZmlsZSBvZiBmaWxlcykge1xuICAgICAgICBsZXQgZmlsZU5hbWUgPSBiYXNlbmFtZShmaWxlKTtcbiAgICAgICAgcGF0aHMucHVzaCh7XG4gICAgICAgICAgZmlsZTogcmVzb2x2ZShzZWFyY2hEaXIsIHByb2pOYW1lLCBmaWxlTmFtZSksXG4gICAgICAgICAgZXhwb3NlOiBgJHtwcm9qTmFtZX0vJHtmaWxlTmFtZX1gXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcGF0aHM7XG4gIH1cbn0iXSwic291cmNlUm9vdCI6Ii9Vc2Vycy9lbXVycmF5L1dlYnN0b3JtUHJvamVjdHMvbGVkZS9zcmMifQ==
